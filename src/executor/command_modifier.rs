use std::{collections::HashMap, fmt::Debug, path::PathBuf};

/// A command modifier is a simple String-based transformation that can be applied to a command
/// generated by an executor. This allows customizing executor behavior beyond the scope of what the
/// FirecrackerArguments and JailerArguments take into consideration, such as prepending, appending or
/// replacing parts of the command string. Multiple command modifiers can also be chained together.
pub trait CommandModifier: Debug + Send + Sync {
    /// Perform the modification of the given command passed by mutable reference.
    fn modify_command(&self, command: &mut String);
}

/// A command modifier that prepends "ip netns exec NETNS " to the actual command, thus utilizing iproute2
/// in order to move the process into a given network namespace.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct NetnsCommandModifier {
    netns_name: String,
    iproute2_path: PathBuf,
}

impl NetnsCommandModifier {
    pub fn new(netns_name: impl Into<String>) -> Self {
        Self {
            netns_name: netns_name.into(),
            iproute2_path: PathBuf::from("/usr/sbin/ip"),
        }
    }

    pub fn iproute2_path(mut self, iproute2_path: impl Into<PathBuf>) -> Self {
        self.iproute2_path = iproute2_path.into();
        self
    }
}

impl CommandModifier for NetnsCommandModifier {
    fn modify_command(&self, command: &mut String) {
        *command = format!(
            "{} netns exec {} {command}",
            self.iproute2_path.to_string_lossy(),
            self.netns_name
        )
    }
}

/// A command modifier that appends an arbitrary string to the end of the original command.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct AppendCommandModifier {
    appended_command: String,
}

impl AppendCommandModifier {
    pub fn new(appended_command: impl Into<String>) -> Self {
        Self {
            appended_command: appended_command.into(),
        }
    }
}

impl CommandModifier for AppendCommandModifier {
    fn modify_command(&self, command: &mut String) {
        command.push_str(&self.appended_command);
    }
}

/// A command modifier that replaces the entire command with an arbitrary string. Not recommended for use
/// unless you are completely certain the rewrite will lead to the correct command!
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RewriteCommandModifier {
    new_command: String,
}

impl RewriteCommandModifier {
    pub fn new(new_command: impl Into<String>) -> Self {
        Self {
            new_command: new_command.into(),
        }
    }
}

impl CommandModifier for RewriteCommandModifier {
    fn modify_command(&self, command: &mut String) {
        *command = self.new_command.clone();
    }
}

/// A command modifier that replaces given strings with other strings in the original command.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ReplaceCommandModifier {
    replacements: HashMap<String, String>,
}

impl ReplaceCommandModifier {
    pub fn new() -> Self {
        Self {
            replacements: HashMap::new(),
        }
    }

    pub fn replace(mut self, original: impl Into<String>, new: impl Into<String>) -> Self {
        self.replacements.insert(original.into(), new.into());
        self
    }
}

impl CommandModifier for ReplaceCommandModifier {
    fn modify_command(&self, command: &mut String) {
        for (original, new) in &self.replacements {
            *command = command.replace(original, new);
        }
    }
}

pub(crate) fn apply_command_modifier_chain(command: &mut String, modifiers: &Vec<Box<dyn CommandModifier>>) {
    for modifier in modifiers {
        modifier.modify_command(command);
    }
}

#[cfg(test)]
mod tests {
    use super::{
        apply_command_modifier_chain, AppendCommandModifier, CommandModifier, NetnsCommandModifier,
        ReplaceCommandModifier, RewriteCommandModifier,
    };

    #[test]
    fn netns_command_modifier_uses_default_iproute2() {
        assert_modifier(
            NetnsCommandModifier::new("test"),
            "command",
            "/usr/sbin/ip netns exec test command",
        );
    }

    #[test]
    fn netns_command_modifier_uses_custom_iproute2() {
        assert_modifier(
            NetnsCommandModifier::new("test").iproute2_path("/custom/path"),
            "command",
            "/custom/path netns exec test command",
        );
    }

    #[test]
    fn append_command_modifier_performs_action() {
        assert_modifier(AppendCommandModifier::new("appended"), "command", "commandappended");
    }

    #[test]
    fn rewrite_command_modifier_performs_action() {
        assert_modifier(RewriteCommandModifier::new("rewritten"), "original", "rewritten");
    }

    #[test]
    fn replace_command_modifier_performs_action() {
        assert_modifier(
            ReplaceCommandModifier::new().replace("a", "b").replace("c", "d"),
            "ac",
            "bd",
        );
    }

    #[test]
    fn apply_command_modifier_chain_performs_chain_of_single_command() {
        let mut command = String::from("command");
        apply_command_modifier_chain(&mut command, &vec![Box::new(AppendCommandModifier::new(" appended"))]);
        assert_eq!(command, "command appended");
    }

    #[test]
    fn apply_command_modifier_chain_performs_chain_of_two_commands() {
        let mut command = String::from("command");
        apply_command_modifier_chain(
            &mut command,
            &vec![
                Box::new(AppendCommandModifier::new(" appended")),
                Box::new(ReplaceCommandModifier::new().replace("app", "APP")),
            ],
        );
        assert_eq!(command, "command APPended");
    }

    #[test]
    fn apply_command_modifier_chain_performs_destructive_command_chain() {
        let mut command = String::from("command");
        apply_command_modifier_chain(
            &mut command,
            &vec![
                Box::new(AppendCommandModifier::new("something")),
                Box::new(RewriteCommandModifier::new("rewritten")),
            ],
        );
        assert_eq!(command, "rewritten");
    }

    fn assert_modifier(modifier: impl CommandModifier, from: &str, to: &str) {
        let mut command = from.to_owned();
        modifier.modify_command(&mut command);
        assert_eq!(command, to);
    }
}
